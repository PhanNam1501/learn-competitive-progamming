Bathroom Stalls  (Google Code jam)

Subtask 1: 1 <= N <= 1000 

Subtask 2: 1 <= N <= 10^6 

Subtask 3: 1 <= N <= 10^18 


Nhận xét: Đề không hề yêu cầu ta phải chỉ ra người thứ K tắm ở phòng tắm nào 

Nhận xét 2: Nguyên tắc chọn phòng tắm chỉ đơn giản là nguyên tắc chọn giống như con người chọn 


Nguyên tắc chọn phòng tắm như sau: 

Xét một đoạn gồm các phòng tắm rỗng liên tục dài nhất, ta vào phòng chính giữa 


Mã giả: 

Q : max heap 

Đưa n vào Q 

Duyệt i: 1 -> K 
  lấy top = Q.top() 
  đặt half1 = top / 2 
  đặt half2 = top - 1 - half1 
  nếu i == K: 
    xuất ra min(half1, half2),  max(half1, half2) 
    DỪNG !!!! 
  đưa half1, half2 vào lại Q 

O(K.logN) 


Subtask 3: 1 <= N <= 10^18 

Gọi count[L] : số lượng đoạn có độ dài = L hiện tại ta đang có 

Đưa L vào Q 

count[L] = 1 

while Q chưa rỗng 
  lấy top của heap 
  đặt half1 = top / 2 
  đặt half2 = top - 1 - half1 
  nếu K <= count[top] 
    xuất ra min(half1, half2) ,   max(half1, half2) 
    DỪNG !!!! 
  K -= count[top]   
  nếu half1 không xuất hiện trong count 
    count[half1] += count[top]  
    đưa half1 vào heap 
  else: 
    count[half1] += count[top]  

  nếu half2 không xuất hiện trong count 
    count[half2] += count[top]  
    đưa half2 vào heap 
  else: 
    count[half2] += count[top]  


N 

---> N / 2,  N / 2 

---> N / 4 

---> N / 8 


====> logN lần chia đôi của số N 

O(logN^2 )

--------------------------------------------------------------------------- 

bitset 

Có N công nhân (1 <= N <= 5000), công nhân thứ i sẽ có một lịch rảnh. 

Một lịch rảnh của công nhân thứ i sẽ gồm một số ngày trong tháng  (ngày : 1 -> 30) 

Hãy chọn 2 công nhân i và j sao cho số lượng ngày rảnh chung của cả 2 người lớn nhất có thể  


N = 3 

Công nhân 1: 2 8 9 10 13 16 17 19 25 26 29 30                          x 

Công nhân 2: 3 4 8 9 11 13 14 17 18 20 25 26 28 29                     x 

Công nhân 3: 1 2 4 5 8 9 10 12 15 16 21 23 24 30 


Ý tưởng ngây thơ: 

maxFree = 0 
Xét 2 công nhân i và j 
   đặt numFree = 0 
   Duyệt từng ngày d: 1 -> 30 
     nếu i rảnh tại d và j rảnh tại d 
       numFree++ 
   maxFree = max(maxFree, numFree)  


1 <= N <= 5000 

O(N^2 * 30) 


bitset

Là một cấu trúc dữ liệu dùng để lưu trữ những dãy bit 


Đơn vị bộ nhớ của máy tính: byte 

một byte sẽ có 8 bit 

Một bit chỉ mang 2 giá trị 0 hoặc 1 

int a = 4; 

00000000000000000000000000000100

int a = 10; 

00000000000000000000000000001010

Khai báo 

#include <bitset> 

Cú pháp 

bitset < <SỐ LƯỢNG BIT> > <tên bitset>; 

Ví dụ: 

bitset <100> mybitset;   // mybitset = 000000000000000000000000.....000000

Một số hàm và toán tử trong bitset 

. Toán tử [<vị trí>] : Gán bit tại vị tương ứng thành giá trị ta mong muốn. Lưu ý nếu ta gán thành một số > 0 thì giá trị = 1 

bitset <100> mybitset;   // mybitset = 000000000000000000000000.....000000

mybitset[0] = 1; 
mybitset[3] = 1;
mybitset[4] = 2; 

// mybitset =  000000000000000000000000.....011001

. Hàm reset() : Reset lại dãy bit để trở về lại thành các bit 0  


bitset <100> mybitset;   // mybitset = 000000000000000000000000.....000000

mybitset[0] = 1; 
mybitset[3] = 1;
mybitset[4] = 2; 

// mybitset =  000000000000000000000000.....011001

mybitset.reset();  


. Hàm count() : Trả về số lượng bit 1 trong bitset 


bitset <100> mybitset;   // mybitset = 000000000000000000000000.....000000

mybitset[0] = 1; 
mybitset[3] = 1;
mybitset[4] = 2; 

// mybitset =  000000000000000000000000.....011001

cout << mybitset.count();  // xuất ra số 3 

+ Một số toán tử trong bitset 


.  Toán tử & 

Xét 2 bitset có cùng số lượng bit A và B.  Đặt C = A & B, bitset C sẽ được thực hiện như sau: 

Với mỗi vị trí i, 

C[i] = 0 nếu A[i] hoặc B[i] = 0 
C[i] = 1 nếu A[i] = 1 và B[i] = 1 


bitset <6> A("101100"), B("011011); 

bitset <6> C = A & B;   // C = 001000


   101100
& 
   011011
----------
   001000 


.  Toán tử | 

Xét 2 bitset có cùng số lượng bit A và B.  Đặt C = A | B, bitset C sẽ được thực hiện như sau: 

Với mỗi vị trí i, 

C[i] = 0 nếu A[i] = 0 và B[i] = 0 
C[i] = 1 nếu A[i] = 1 hoặc B[i] = 1 


bitset <6> A("101100"), B("011011); 

bitset <6> C = A | B;   // C = 111111


   101100
| 
   011011
----------
   111111


. Toán tử ^ 

Xét 2 bitset có cùng số lượng bit A và B.  Đặt C = A ^ B, bitset C sẽ được thực hiện như sau: 

Với mỗi vị trí i, 

C[i] = 0 nếu A[i] và B[i] giống nhau  
C[i] = 1 nếu A[i] khác B[i] 


bitset <6> A("101100"), B("011011); 

bitset <6> C = A ^ B;   // C = 110111


   101100
^ 
   011011
----------
   110111 


. Toán tử << 

Xét bitset A, đặt B = A << x,   bitset B sẽ là bitset A nhưng những vị trí tương ứng của bitset A sẽ được dịch sang trái x đơn vị 


bitset <10> A("0110011001"); 

bitset <10> B = A << 3;   //       B =   0011001000



. Toán tử >>

Xét bitset A, đặt B = A >> x,   bitset B sẽ là bitset A nhưng những vị trí tương ứng của bitset A sẽ được dịch sang phải x đơn vị 


bitset <10> A("0110011001"); 

bitset <10> B = A >> 3;   //       B =   0000110011

Các toán tử trong bitset có độ phức tạp: O(V / 64)  với V là số lượng bit trong bitset 


Quay trở lại bài toán công nhân 

Xét lịch rảnh của người công nhân i 

Lịch rảnh của người i là một bitset có 30 bit. Trong đó bit thứ d = 1 nếu ngày d của người i rảnh 


bitset <30> freeDays[5005]; 

Với mỗi công nhân i 
  Duyệt từng ngày rảnh d 
    freeDays[i][d] = 1 


đặt maxFree = 0 
Duyệt i: 1 -> N  
  Duyệt j: i + 1 -> N 
     đặt bitset <30> common = freeDays[i] & freeDays[j] 
     maxFree = max(maxFree, common.count())

------------------------------------------------------------------------------

Triangles 

Có N số nguyên từ 1 -> N. 

Ta có một bảng a với ý nghĩa: 

a[i][j] = 1: Có một que nối từ số i sang số j 

a[i][j] = 0: không có que nối từ i sang j 

Đếm có bao nhiêu bộ (i, j, k) sao cho: i nối sang j, j nối sang k, k nối sang i 


(1, 3, 4) 


1 <= N <= 3000 

Giả sử ta có i và j  có que nối  (i < j) 

Có bao nhiêu số k sao cho: 

k > i 
k > j 

k nối i 
k nối j 


Gọi match[i] : bitset chứa các j sao cho: 

j > i 

nếu i có nối với j  thì bit thứ j = 1 


Duyệt i: 1 -> N  
  Duyệt j: i + 1 -> N 
    Nếu a[i][j] == 1: 
      match[i][j] = 1 


ans = 0 
Duyệt i: 1 -> N 
  Duyệt j: i + 1 -> N 
    đặt common = match[i] & match[j] 
    ans += common.count() 

Xuất ra ans 
















