Phân tích chi tiết code
Bài toán 
Cho n đoạn thẳng [l[i], r[i]], chọn k đoạn sao cho phần giao của chúng có độ dài lớn nhất.


Phần 1: Struct Node và min-heap
struct Node {
    int idx;      // chỉ số đoạn (0-indexed)
    long long r;  // giá trị r của đoạn
    
    bool operator<(const Node& other) const {
        return r > other.r;  // ĐẢO NGƯỢC để tạo min-heap
    }
};

Giải thích:
+ priority_queue đang là min 

Phần 2: Đọc input và sort theo l


vector<int> idx(n);
iota(idx.begin(), idx.end(), 0);  // idx = {0, 1, 2, ..., n-1}

sort(idx.begin(), idx.end(), [&](int a, int b) {
    return l[a] < l[b];  // sort theo l tăng dần
});


**Giải thích:**
- `iota`: gán idx = {0, 1, 2, ..., n-1}
- Sort `idx` theo giá trị `l` tương ứng, nhưng **không thay đổi mảng l, r gốc**
- Sau sort: `idx[0]` là đoạn có `l` nhỏ nhất, `idx[n-1]` là đoạn có `l` lớn nhất

**Ví dụ:**
Đoạn 0: [5, 10]
Đoạn 1: [2, 8]
Đoạn 2: [3, 12]

Sau sort theo l: idx = {1, 2, 0}
→ idx[0]=1 (l=2), idx[1]=2 (l=3), idx[2]=0 (l=5)

Phần 3: Thuật toán chính - Sweep line + Min-heap

priority_queue<Node> pq;
long long maxLen = 0;
int bestT = -1;

for (int t = 0; t < n; t++) {
    int i = idx[t];           // đoạn thứ i (theo thứ tự l tăng dần)
    pq.push({i, r[i]});       // thêm vào heap
    
    while ((int)pq.size() > k) 
        pq.pop();             // giữ lại k đoạn có r lớn nhất
    
    if ((int)pq.size() == k) {
        long long len = pq.top().r - l[i] + 1;  // tính độ dài giao
        if (len > maxLen) {
            maxLen = len;
            bestT = t;        // lưu vị trí tốt nhất
        }
    }
}

Ý tưởng cốt lõi:
Giao của k đoạn = [max(l), min(r)]
Khi duyệt theo thứ tự l tăng dần:

Tại bước t: l[idx[t]] là l lớn nhất trong các đoạn đã xét (idx[0..t])
Ta muốn chọn k đoạn sao cho min(r) lớn nhất → dùng min-heap giữ k đoạn có r lớn nhất

Chi tiết từng bước:
Bước                                Hành động
pq.push({i, r[i]})                  Thêm đoạn i vào heap
while (pq.size() > k) pq.pop()      Loại bỏ đoạn có r nhỏ nhất, giữ lại k đoạn có r lớn nhất
pq.top().r                          Giá trị r nhỏ nhất trong k đoạn đang giữ = min(r)
l[i]                                Giá trị l lớn nhất (vì sort theo l tăng dần) = max(l)
len = pq.top().r - l[i] + 1         Độ dài giao = min(r) - max(l) + 1
Tại sao chỉ lưu bestT?
Code cũ copy cả priority_queue mỗi lần update → O(k log k) mỗi lần.
Code mới chỉ lưu bestT, reconstruct ở cuối 1 lần duy nhất → nhanh hơn nhiều.

Ví dụ có thể thấy là:
5 2
1 10
5 15
14 50
30 70
99 100

t = 0
heap {10}, l[t] = 1
t = 1
heap {10, 15} l[t] = 5
-> maxx = min(heap) - l[t] + 1 = 10 - 5 + 1 = 6
t = 2 
heap {10, 15, 50} -> pop(10) -> heap {15, 50} ...
Ta phải để ý trick chính là nếu ta sắp xếp l theo thứ tự tăng dần thì lúc đó mặc định là khi tăng thứ tự lên thì thứ khiến maxx tăng duy nhất là r vì l tăng làm giảm độ dài


Phần 5: Reconstruct đáp án
cppelse {
    // Thu thập tất cả đoạn từ idx[0] đến idx[bestT]
    vector<pair<long long, int>> candidates;
    for (int t = 0; t <= bestT; t++) {
        int i = idx[t];
        candidates.push_back({r[i], i + 1});  // {r, index 1-based}
    }
    
    // Sort giảm dần theo r
    sort(candidates.begin(), candidates.end(), greater<pair<long long, int>>());
    
    // Lấy k đoạn có r lớn nhất
    vector<int> ans;
    for (int j = 0; j < k; j++) {
        ans.push_back(candidates[j].second);
    }
    
    // Sort để in theo thứ tự tăng dần
    sort(ans.begin(), ans.end());
    
    for (int x : ans) 
        cout << x << " ";
}
```

#### Tại sao cách này đúng?

Tại `bestT`, ta đã xét các đoạn `idx[0], idx[1], ..., idx[bestT]`:
- Đây là tất cả các đoạn có `l ≤ l[idx[bestT]]`
- Heap lúc đó giữ k đoạn có r lớn nhất trong số này
- → Reconstruct: lấy k đoạn có r lớn nhất trong `idx[0..bestT]`

#### Ví dụ reconstruct:
```
bestT = 4
idx[0..4] tương ứng với đoạn: 2, 1, 5, 3, 4

candidates = [(r[2], 2), (r[1], 1), (r[5], 5), (r[3], 3), (r[4], 4)]
           = [(8, 2), (10, 1), (9, 5), (12, 3), (7, 4)]

Sort giảm theo r: [(12,3), (10,1), (9,5), (8,2), (7,4)]

Lấy k=3 đầu: [3, 1, 5]
Sort tăng: [1, 3, 5]

Output: 1 3 5